<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Exploring the Floating Point Performance of Modern ARM Processors -</title><meta name=robots content="index,follow,noarchive"><meta name=description content="As a programmer who wants to write decent performing code, I am very interested in understanding the architectures of CPUs and GPUs. However, unlike desktop and server CPUs, mobile CPU and GPU vendors tend to do very little architectural disclosure - a fact that we've been working hard to change over the past few years. Often times all that's available are marketing slides with fuzzy performance claims. This situation frustrates me to no end personally."><meta name=author content="Reinaldo Massengill"><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/app.css><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/an-old-hope.min.css><script defer src=https://assets.cdnweb.info/hugo/paper/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=./theme.png><link rel=icon href=./favicon.ico><link rel=apple-touch-icon href=./apple-touch-icon.png><meta name=generator content="Hugo 0.98.0"><meta property="og:title" content="Exploring the Floating Point Performance of Modern ARM Processors"><meta property="og:description" content="As a programmer who wants to write decent performing code, I am very interested in understanding the architectures of CPUs and GPUs. However, unlike desktop and server CPUs, mobile CPU and GPU vendors tend to do very little architectural disclosure - a fact that we've been working hard to change over the past few years."><meta property="og:type" content="article"><meta property="og:url" content="/exploring-the-floating-point-performance-of-modern-arm-processors.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-01T00:00:00+00:00"><meta itemprop=name content="Exploring the Floating Point Performance of Modern ARM Processors"><meta itemprop=description content="As a programmer who wants to write decent performing code, I am very interested in understanding the architectures of CPUs and GPUs. However, unlike desktop and server CPUs, mobile CPU and GPU vendors tend to do very little architectural disclosure - a fact that we've been working hard to change over the past few years."><meta itemprop=datePublished content="2024-04-01T00:00:00+00:00"><meta itemprop=dateModified content="2024-04-01T00:00:00+00:00"><meta itemprop=wordCount content="1851"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Exploring the Floating Point Performance of Modern ARM Processors"><meta name=twitter:description content="As a programmer who wants to write decent performing code, I am very interested in understanding the architectures of CPUs and GPUs. However, unlike desktop and server CPUs, mobile CPU and GPU vendors tend to do very little architectural disclosure - a fact that we've been working hard to change over the past few years."></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=./index.html>BlogNews</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=./sitemap.xml>Sitemap</a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Apr 1, 2024</time>
<span>Reinaldo Massengill</span></p><h1>Exploring the Floating Point Performance of Modern ARM Processors</h1></header><section class=post-content><img src=https://cdn.statically.io/img/images.anandtech.com/doci/6971/Screen%20Shot%202013-06-02%20at%2010.40.32%20PM_678x452.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>As a programmer who wants to write decent performing code, I am very interested in understanding the architectures of CPUs and GPUs. However, unlike desktop and server CPUs, mobile CPU and GPU vendors tend to do very little architectural disclosure - a fact that we've been working hard to change over the past few years. Often times all that's available are marketing slides with fuzzy performance claims. This situation frustrates me to no end personally. We've done quite a bit of low-level mobile CPU analysis at AnandTech in pursuit of understanding architectures where there is no publicly available documentation. In this spirit, I wrote a few synthetic tests to better understand the performance of current-gen ARM CPU cores without having to rely upon vendor supplied information. For this article I'm focusing exclusively on floating point performance.</p><p>We will look at 5 CPU cores today: the ARM Cortex A9, ARM Cortex A15, Qualcomm Scorpion, Qualcomm Krait 200 and Qualcomm Krait 300.&nbsp; The test devices are listed below.<br>&nbsp;</p><table border=1 cellpadding=1 cellspacing=1>Devices tested<tbody readability=2><tr><td>Device</td><td>OS</td><td>SoC</td><td>CPU</td><td>Frequency</td><td>Number of cores</td></tr><tr readability=2><td>Samsung Galaxy SIIX (T989D)</td><td>Android 4.0</td><td>Qualcomm APQ8060</td><td>Scorpion</td><td>1.5GHz</td><td>2</td></tr><tr readability=2><td>Boundary devices BD-SL-i.mx6</td><td>Ubuntu Oneiric</td><td>Freescale i.mx6</td><td>Cortex-A9</td><td>1.0GHz</td><td>4</td></tr><tr><td>Blackberry Z10</td><td>Blackberry 10 (10.1)</td><td>Qualcomm MSM8960</td><td>Krait 200</td><td>1.5GHz</td><td>2</td></tr><tr><td>Google Nexus 10</td><td>Android 4.2.2</td><td>Samsung Exynos 5250</td><td>Cortex-A15</td><td>1.7GHz</td><td>2</td></tr><tr><td>HTC One</td><td>Android 4.1.2</td><td>Qualcomm Snapdragon 600</td><td>Krait 300</td><td>1.7GHz</td><td>4</td></tr></tbody></table><p><br>I wanted to test the instruction throughput of various floating point instructions. I wrote a simple benchmark consisting of a loop with a large number of iterations.&nbsp; The loop body consisted of many (say 20) floating point instructions with no data dependence between them. The tests were written in C++ with gcc NEON intrisincs where required, and I always checked the assembler to verify that the generated assembly was as expected. There were no memory instructions inside the loop and thus memory performance was not an issue. There were minimal dependencies in the loop body. I tested the performance of scalar addition, multiplication and multiply-accumulate for 32-bit and 64-bit floating point datatypes. All the tested ARM processors also support the NEON instruction set, which is a SIMD (single instruction multiple data) instruction set for ARM for integer and floating point operations. I tested the performance of 128-bit floating point NEON instructions&nbsp; for addition, multiplication and multiply-accumulate. &nbsp;</p><p>Apart from testing throughput of individual instructions, I also wrote a test for testing throughput of a program consisting of two types of instructions: scalar addition and scalar multiplication instructions. The instructions were interleaved, i.e. the program consisted of an addition followed by a multiply, followed by another add, then another multiply and so on. There were no dependencies between the additions and following multiplies. You may be wondering the reasoning behind this mixed test. Some CPU cores (such as AMD's K10 core) have two floating point units but the two floating point units may not be identical. For example, one floating point unit may only support addition while another may only support multiplication. Thus, if we only test the additions and multiplications separately, we will not see the peak throughput on such a machine. We perform the mixed test to identify such cases.</p><p>All the tests mentioned above measure the amount of time taken for a particular number of instructions and thus we get the instructions executed per-second. We also need to know the frequency to get the instructions executed&nbsp; per-cycle. Knowing the peak frequency of the device is not enough because CPUs have multiple frequency states and the tests may not be running at the advertised peak speeds. Thus, I also wrote code to monitor the percentage of time spent in each frequency state as reported by the kernel. The frequency was calculated as the&nbsp; average of the frequency states weighted by percentage of time spent in each state.&nbsp; The observed frequency on Scorpion (APQ8060) , Cortex A9 (i.mx6) and Cortex A15 (Exynos 5250) were 1.242 GHz, 992MHz and 1.7GHz respectively on all tests except where noted in the results below.</p><p>However, as it turns out, the method I used for measuring the time spent in each frequency state does not work on aSMP designs like the Krait 200 based Snapdragon S4 and Krait 300 based Snapdragon 600.&nbsp; For Krait 200, the results reported here are for MSM8960 which shouldn't really have thermal throttling issues. My results on the MSM8960 also line up quite neatly with the assumption that the CPU spent most or all of its time in the test in the peak frequency state. Brian also ran the test on a Nexus 4 and the results were essentially identical as both have the same peak, which is additional confirmation that our results are likely correct. Thus I will assume a frequency of 1.5 GHz while discussing Krait 200 results.&nbsp; Results on Krait 300 (Snapdragon 600) however are more mixed. I am not sure if it is reaching peak frequency on all the tests and thus I am less sure of the per-cycle estimates on this chip. Brian also ran the tests on another handset (LG Optimus G Pro) with the same Snapdragon 600, and the results were qualitatively very similar.</p><p>Now the results. First up, the raw data collected from the tests in gigaflops:</p><table border=1 cellpadding=1 cellspacing=1>Performance of each CPU in GFlops on different tests<tbody readability=1><tr readability=2><td>&nbsp;</td><td><p>Scorpion&nbsp;&nbsp;</p><p>(APQ8060)</p></td><td><p>Cortex-A9</p><p>(i.mx6)</p></td><td><p>Krait 200</p><p>(MSM8960)</p></td><td><p>Cortex-A15</p><p>(Exynos 5250)</p></td><td><p>Krait 300</p><p>(Snapdragon 600)</p></td></tr><tr><td>Add (fp64)</td><td>1.23</td><td>0.99</td><td>1.33</td><td>1.55&nbsp; @ 1.55 GHz</td><td>1.6</td></tr><tr><td>Add (fp32)</td><td>1.19</td><td>0.99</td><td>1.46</td><td>1.69</td><td>1.72</td></tr><tr><td>Mul (fp64)</td><td>0.61</td><td>0.50</td><td>1.48</td><td>1.69</td><td>1.72</td></tr><tr><td>Mul (fp32)</td><td>1.22</td><td>0.99</td><td>1.49</td><td>1.69</td><td>1.72</td></tr><tr><td>Mixed (fp64)</td><td>0.82</td><td>0.99</td><td>1.48</td><td>1.63</td><td>1.72</td></tr><tr><td>Mixed (fp32)</td><td>1.23</td><td>0.99</td><td>1.47</td><td>1.69</td><td>1.72</td></tr><tr><td>MAC (fp64)</td><td>1.23</td><td>0.99</td><td>1.48</td><td>3.35</td><td>2.65</td></tr><tr><td>MAC (fp32)</td><td>2.47</td><td>1.98</td><td>1.47</td><td>3.39</td><td>3.13</td></tr><tr><td>Add (fp32 NEON)</td><td>4.94</td><td>1.99</td><td>5.86</td><td>6.77</td><td>6.89</td></tr><tr><td>Mul (fp32 NEON)</td><td>4.89</td><td>1.99</td><td>5.76</td><td>6.77</td><td>6.89</td></tr><tr><td>MAC (fp32 NEON)</td><td>9.88</td><td>3.98</td><td>5.91</td><td>13.55</td><td>12.5</td></tr></tbody></table><p>Before we discuss the results, it is important to keep in mind that the results and per-cycle timing estimates reported are what I observed from the tests. I did my best to ensure that the design of the tests was very conducive to achieving high throughput. However, it is possible there may be some cases where an architecture can achieve higher performance than what what I was able to get out of my tests. With that out of the way, lets look at the results.</p><p>In the data, we need to distinguish between number of instructions and number of flops. I count scalar addition and multiply as one flop and scalar MACs as two flops. I count NEON addition and multiply as four flops and NEON MACs are counted as eight flops. Thus, we get the following per-cycle instruction throughput estimates:</p><table border=1 cellpadding=1 cellspacing=1>Estimated floating point instruction throughput per cycle<tbody><tr><td>&nbsp;</td><td>Scorpion</td><td>Cortex A9</td><td>Krait 200</td><td>Cortex A15</td><td>Krait 300</td></tr><tr><td>Add (fp64)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Add (fp32)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mul (fp64)</td><td>1/2</td><td>1/2</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mul (fp32)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mixed (fp64)</td><td>2/3</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mixed (fp32)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MAC (fp64)</td><td>1/2</td><td>1/2</td><td>1/2</td><td>1</td><td>7/9</td></tr><tr><td>MAC (fp32)</td><td>1</td><td>1</td><td>1/2</td><td>1</td><td>10/11</td></tr><tr><td>Add (fp32 NEON)</td><td>1</td><td>1/2</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mul (fp32 NEON)</td><td>1</td><td>1/2</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MAC (fp32 NEON)</td><td>1</td><td>1/2</td><td>1/2</td><td>1</td><td>10/11</td></tr></tbody></table><p>We start with the Cortex A9. Cortex A9 achieves throughput of 1 operation/cycle for most scalar instructions, except for fp64 MUL and fp64 MAC, which can only be issued once every two cycles. The mixed test reveals that though fp64 muls can only be issued every two cycles, Cortex A9 can issue a fp64 add in the otherwise empty pipeline slot. Thus, in the mixed test it was able to achieve throughput of 1 instruction/cycle. NEON implementation in Cortex A9 has a 64-bit datapath and all NEON instructions take 2 cycles. Qualcomm's Scorpion implementation of scalar implementations is similar to Cortex A9 except that it seems unable to issue fp64 adds immediately after fp64 muls in the mixed test. Scorpion uses a full 128-bit datapath for NEON and has twice the throughput of Cortex A9.</p><p>Krait 200 features an improved multiplier, and offers 1 instruction/cycle throughput for most scalar and NEON instructions. Interestingly, Krait 200 has half the per-cycle throughput for MAC instructions, which is a regression compared to Scorpion. Krait 300 improves the MAC throughput compared to Krait 200, but still appears to be unable to reach throughput of 1 instruction/cycle possibly revealing some issues in the pipeline. An alternate explanation is that Snapdragon 600 reduced the frequency in the MAC tests for some unknown reason. Without accurate frequency information, currently it is difficult to make that judgment. Cortex A15 is the clear leader here, and offers throughput of 1 FP instruction/cycle in all our tests.</p><p>In the big picture, readers may want to know how the the floating point capabilities of these cores compares to x86 cores.&nbsp; I consider Intel's Ivy Bridge and Haswell as datapoints for big x86 cores, and AMD Jaguar as a datapoint for a small x86 core. For double-precision (fp64), current ARM cores appear to be limited to 2 flops/cycle for FMAC-heavy workloads and 1 flops/cycle for non-FMAC workloads. Ivy Bridge can have a throughput of up to 8 flops/cycle and Haswell can do 16 flops/cycle with AVX2 instructions. Jaguar can execute up to 3 flops/cycle.&nbsp; Thus, current ARM cores are noticeably behind in this case. Apart from the usual reasons (power and area constraints, very client focused designs), current ARM cores also particularly lag behind in this case because currently NEON does not have vector instructions for fp64. ARMv8 ISA adds fp64 vector instructions and high performance implementations of the ISA such as Cortex A57 should begin to reduce the gap.</p><p>For fp32, Ivy Bridge can execute up to 16 fp32 flops/cycle, Haswell can do up to 32 fp32 flops/cycle and AMD's Jaguar can perform 8 fp32 flops/cycle.&nbsp; Current ARM cores can do up to 8 flops/cycle using NEON instructions. However, ARM NEON instructions are not IEEE 754 compliant, whereas SSE and AVX floating point instructions are IEEE 754 compliant. Thus, comparing flops obtained in NEON instructions to SSE instructions is not apples-to-apples comparison. Applications that require IEEE 754 compliant arithmetic cannot use NEON but more consumer oriented applications such as multimedia applications should be able to use NEON. Again, ARMv8 will fix this issue and will bring fully IEEE 754-compliant fp32 vector instructions.</p><p>To conclude, Cortex A15 clearly leads amongst the CPUs tested today with Krait 300 very close behind. It is also somewhat disappointing that none of the CPU cores tested displayed a throughput of more than 1 FP instruction/cycle in these tests. I end at a cautionary note that the tests here are synthetic tests that only stress the FP units. Floating point ALU peaks are only a part of a microarchitecture. Performance of real-world applications will depend upon rest of the microarchitecture such as cache hierarchy, out of order execution capabilities and so on. We will continue to make further investigations into these CPUs to understand them better.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZIN6g5BonLGonKS%2FqrrGZquhnV2bubCt06KloGWgpLavwIypnKuen6e6orrCnmSonl2ivKWx0adkmqqdYr2zu8Keqqynoqg%3D</p></section><nav class=post-nav><a class=prev href=./lyrics-lovejoy-oh-yeah-you-gonna-cry.html><span>←</span><span>LYRICS: Lovejoy Oh Yeah, You Gonna Cry?</span></a>
<a class=next href=./true-blood-reboot-hbo.html><span>Fan Casting Will Poulter as Godric in True Blood : REBOOT [HBO] on myCast</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=./></a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>